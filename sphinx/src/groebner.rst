.. _thesis-groebner:

.. include:: ../globals.def

=================================================
Introduction to |groebner| bases and applications
=================================================



Specialization of |groebner| bases
==================================

The |groebner| bases algorithm specializes to:

1. *Gauss's algorithm* for linear polynomials
2. *Euclid's algorithm* for univariate polynomials

Examples
--------

For the first case lets consider the following equation system:

.. math::

    \begin{cases}
       x + 5 y = 2    \\
    -3 x + 6 y = 15
    \end{cases}

which can be written in Python as::

    >>> F = [x + 5*y - 2, -3*x + 6*y - 15]

It's a simple system, so it can be solved by hand. We can, however, uses |groebner| bases
algorithm to solve this system algorithmically::

    >>> groebner(F, x, y)
    [x + 3, y - 1]

As the result we got a list of two polynomials. From te list we can obtain the solution
of the system, which is $x = -3$ and $y = 1$ in this case. The same can be computed using
a much more traditional tool in the field of linear algebra, mainly using Gauss--Jordan
algorithm::

    >>> solve(F, x, y)
    {x: -3, y: 1}

We obtained the same solution but in the dictionary form this time. It's interesting to
notice that currently, at least for small inputs, the |groebner| bases approach is much
faster than using a specialized solver. Lets compare efficiency of those two methods::

    >>> %timeit groebner(F, x, y)
    100 loops, best of 3: 5.15 ms per loop

    >>> %timeit solve(F, x, y)
    10 loops, best of 3: 22.7 ms per loop

An explanation of this result is as follows: |groebner| bases utilize very efficient core
of polynomials manipulation module, whereas :func:`solve` inefficient implementation of
linear algebra in SymPy. This situation will change and the observed phenomenon will
disappear in future, when linear algebra module is refactored (using similar approach
to what was done to polynomials module).

Lets now focus on the other case, i.e. on computation of the greatest common divisors. For
this, consider two univariate polynomials ``f`` and ``g``, both in the indeterminate ``x``
with coefficients in the ring of integers::

    >>> f = expand((x - 2)**3 * (x + 3)**4 * (x + 7))
    >>> g = expand((x + 2)**3 * (x + 3)**3 * (x + 7))

We can easily see that those polynomials have to factors in common (of multiplicity three
and one respectively). Lets verify this observation using |groebner| bases algorithm once
again::

    >>> groebner([f, g])
    ⎡ 4       3       2              ⎤
    ⎣x  + 16⋅x  + 90⋅x  + 216⋅x + 189⎦

We obtained a polynomial of degree four which clearly verifies observation concerning
multiplicities of the commons factors of ``f`` and ``g``. Lets add more structure to
the computed polynomial GCD using factorization::

    >>> factor(_[0])
           3
    (x + 3) ⋅(x + 7)

Now we can clearly see the common factors of the input polynomials. Although utilization
of |groebner| bases algorithm for computing GCDs of univariate polynomials is very fancy,
there are much more efficient algorithm for this purpose. In SymPy we use heuristic GCD
algorithm (over integers and rationals) and subresultants (over other domains).

Moreover, |groebner| bases can be used to compute greatest common divisors of multivariate
polynomials (see [Cox1997ideals]_). The algorithm reduces the problem of finding the GCD of
two multivariate polynomials, say ``f`` and ``g``, into the problem of finding their least
common multiple. The final result is obtained using the well known formula that relates
GCD with LCM:

.. math::

    \gcd(f, g) = \frac{f \cdot g}{\operatorname{lcm}(f, g)}

The multivariate polynomial LCM is computed as the unique generator of the intersection of
the two ideals generated by ``f`` and ``g``. The approach is to compute a |groebner| basis
of $t \cdot f$ and $(1 - t) \cdot g$, where $t$ is an unrelated variable, with respect to
lexicographic order of terms which eliminates $t$. The polynomial LCM of ``f`` and ``g``
is the last element of the computed |groebner| basis.

Historically this was the first algorithm for computing GCDs of multivariate polynomials
in SymPy. Although it's not a very efficient approach to the problem, it can serve as a
good explanation of |groebner| bases machinery. Currently we use heuristic GCD algorithm
and there are plans to implement EEZ algorithm for this task (see section [thesis-gcd]_
for more details).

Reduced |groebner| bases
========================

Complexity of computing |groebner| bases
========================================

::
    GroebnerBasis[{x y^3 - 2 y z - z^2 + 13, y^2 - x^2 z + x z^2 + 3, z^2 x - y^2 x^2 + x y + y^3 + 12}]

::
    groebner([x*y**3 - 2*y*z - z**2 + 13, y**2 - x**2*z + x*z**2 + 3, z**2*x - y**2*x**2 + x*y + y**3 + 12], x, y, z)

A few applications of |groebner| bases
======================================

Solving systems of equations
----------------------------

Vertex-coloring of graphs
-------------------------

.. math::

    V(I)


.. [Cox1997ideals]
.. [thesis-gcd]

