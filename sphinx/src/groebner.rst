.. include:: ../globals.def

.. _thesis-groebner:

=======================================================
Introduction to |groebner| bases and their applications
=======================================================

Construction of |groebner| bases
================================

Specialization of |groebner| bases
==================================

The |groebner| bases algorithm specializes to:

1. *Gauss's algorithm* for linear polynomials
2. *Euclid's algorithm* for univariate polynomials

In the first case lets consider the following system of equations:

.. math::

    \left\{
    \begin{array}{rcl}
       x + 5 y &=& 2    \\
    -3 x + 6 y &=& 15
    \end{array}
    \right.

which can be written in Python as::

    >>> F = [x + 5*y - 2, -3*x + 6*y - 15]

It's a simple system, so it can be solved by hand. We can, however, use |groebner| bases
machinery to solve this system algorithmically::

    >>> groebner(F, x, y)
    [x + 3, y - 1]

As the result we got a list of two polynomials. From te list we can obtain the solution
of the system, which is $x = -3$ and $y = 1$ in this case. The same can be computed using
a much more traditional tool in the field of linear algebra, mainly using Gauss--Jordan
algorithm::

    >>> solve(F, x, y)
    {x: -3, y: 1}

We obtained the same solution but in the dictionary form this time. It's interesting to
notice that currently, at least for small inputs, the |groebner| bases approach is much
faster than using a specialized solver. Lets compare efficiency of those two methods::

    >>> %timeit groebner(F, x, y)
    100 loops, best of 3: 5.15 ms per loop

    >>> %timeit solve(F, x, y)
    10 loops, best of 3: 22.7 ms per loop

An explanation of this result is as follows: |groebner| bases utilize very efficient core
of polynomials manipulation module, whereas :func:`solve` uses inefficient implementation
of linear algebra in SymPy. This situation will change and the observed phenomenon will
disappear in future, when linear algebra module is refactored (using similar approach
to what was done to polynomials module).

Lets now focus on the other case, i.e. on computation of the greatest common divisors. For
this, consider two univariate polynomials ``f`` and ``g``, both in the indeterminate ``x``
with coefficients in the ring of integers::

    >>> f = expand((x - 2)**3 * (x + 3)**4 * (x + 7))
    >>> g = expand((x + 2)**3 * (x + 3)**3 * (x + 7))

We can easily see that those polynomials have to factors in common (of multiplicity three
and one respectively). Lets verify this observation using |groebner| bases algorithm once
again::

    >>> groebner([f, g])
    ⎡ 4       3       2              ⎤
    ⎣x  + 16⋅x  + 90⋅x  + 216⋅x + 189⎦

We obtained a polynomial of degree four which clearly verifies observation concerning
multiplicities of the commons factors of ``f`` and ``g``. Lets add more structure to
the computed polynomial GCD using factorization::

    >>> factor(_[0])
           3
    (x + 3) ⋅(x + 7)

Now we can clearly see the common factors of the input polynomials. Although utilization
of |groebner| bases algorithm for computing GCDs of univariate polynomials is very fancy,
there are much more efficient algorithm for this purpose. In SymPy we use heuristic GCD
algorithm (over integers and rationals) and subresultants (over other domains).

Moreover, |groebner| bases can be used to compute greatest common divisors of multivariate
polynomials (see [Cox1997ideals]_). The algorithm reduces the problem of finding the GCD of
two multivariate polynomials, say ``f`` and ``g``, into the problem of finding their least
common multiple. The final result is obtained using the well known formula that relates
GCD with LCM:

.. math::
    :label: gcdlcm

    \gcd(f, g) = \frac{f \cdot g}{\operatorname{lcm}(f, g)}

The multivariate polynomial LCM is computed as the unique generator of the intersection of
the two ideals generated by ``f`` and ``g``. The approach is to compute a |groebner| basis
of $t \cdot f$ and $(1 - t) \cdot g$, where $t$ is an unrelated variable, with respect to
lexicographic order of terms which eliminates $t$. The polynomial LCM of ``f`` and ``g``
is the last element of the computed |groebner| basis.

As an example consider the following two bivariate polynomials over integers::

    >>> f = expand((x - 1)**3 * (x + y)**4 * (x - y))
    >>> g = expand((x + 1)**3 * (x + y)**3 * (x - y))

To compute the GCD of ``f`` and ``g`` we will introduce new variable $t$ and then we will
find a |groebner| basis of $t \cdot f$ and $(1 - t) \cdot g$ which eliminates $t$::

    >>> basis = groebner([t*f, (1 - t)*g], t, x, y)

Note that the order of variables is significant. We chose $t$ to be of higher rank than
$x$ or $y$ to allow |groebner| basis algorithm to eliminate it from the last element of
the basis. As the relative rank of $x$ and $y$ is not important in this case, we can
rewrite the above expression in a slightly different form::

    >>> basis = groebner([t*f, (1 - t)*g], wrt=t)

This syntax signifies that the only important knowledge here is that $t$ comes before
any other variable. This approach is also far more general because we could use input
polynomials with more variables without changing the algorithm, as long as there is no
clash of variables with $t$. We can guarantee that this won't happen by declaring $t$
as a *dummy* variable, i.e. ``t = Symbol('t', dummy=True)``.

Also one should note that we didn't specify the order of terms in |groebner| basis
computation. As we use *lexicographic* order for computing the LCM of ``f`` and ``g``
we need to provide no further information, because all algorithms in polynomials
manipulation module use *lexicographic* order of terms by default.

Given a |groebner| basis of the ideal generated by ``f`` and ``g``, the last element
of this basis is the desired LCM. By using formula :eq:`gcdlcm` we can compute the
greatest common divisor of the input polynomials::

    >>> quo(f*g, basis[-1])
     4        3        3    4
    x  + 2⋅y⋅x  - 2⋅x⋅y  - y

    >>> factor(_)
           3
    (x + y) ⋅(x - y)

We obtained the correct GCD of ``f`` and ``g``. As in the univariate case, the same
result can computed, thought much more efficiently, using :func:`gcd` function, which
utilizes specialized algorithms for computing greatest common divisors.

Historically this was the first algorithm for computing GCDs of multivariate polynomials
in SymPy. Although it's not a very efficient approach to the problem, it can serve as a
good explanation of |groebner| bases machinery. Currently we use heuristic GCD algorithm
for the task and there are plans to implement EEZ algorithm for this task (see section
:ref:`thesis-gcd` for more details).

Reduced |groebner| bases
========================

Complexity of computing |groebner| bases
========================================

::

    GroebnerBasis[{x y^3 - 2 y z - z^2 + 13, y^2 - x^2 z + x z^2 + 3, z^2 x - y^2 x^2 + x y + y^3 + 12}]

::

    groebner([x*y**3 - 2*y*z - z**2 + 13, y**2 - x**2*z + x*z**2 + 3, z**2*x - y**2*x**2 + x*y + y**3 + 12], x, y, z)

Applications of |groebner| bases
================================

|groebner| bases are

* Algebraic Geometry
* Coding Theory
* Cryptography
* Invariant Theory
* Integer Optimization
* Statistics
* Symbolic Integration
* Symbolic Summation
* Differential Equations

 * Boundary Value Problems

* Systems Theory


Solving systems of polynomial equations
---------------------------------------

In the previous section we showed that |groebner| bases can be used for solving systems
of linear equations. This is an interesting, although not very useful result because we
have specialized algorithms for the task. However, |groebner| bases can used to tackle
much more complicated problem: finding solutions of systems of *polynomial* equations.

To accomplish this we will utilize a very fruitful property of |groebner| bases, so called,
elimination property. Following [Buchberger2001introduction]_ and [Adams1994intro]_, suppose
$F$ is a set of polynomial equations, such that every element of $F$ belongs to $\mathbb{K}[x_1,
\ldots, x_n]$, where $\mathbb{K}$ is a field of positive characteristic, and $G$ is its |groebner|
computed with respect to any *elimination* ordering of terms (e.g. lexicographic ordering). We
assume that $x_1 \succ \ldots \succ x_n$. Then $F$ and $G$ generate the same ideal, so they have
the same set of solutions. The elimination property of |groebner| bases guarantees that if $G$ has
only a finite number of solutions then $G$ has exactly one polynomial in $x_n$, i.e. a univariate
polynomial which can solved. As :func:`groebner` returns a sorted basis, the univariate polynomial
will be the last element the basis.

In principle the algorithm works as follows: given a set of polynomial equations $F$ we compute
its |groebner| basis $G$ with respect to lexicographic term order. If $G$ has only one univariate
polynomial then we solve it, e.g. by radicals (if possible), and substitute the solutions back to
$G$, skipping the univariate polynomial we already solved, obtaining a set of smaller polynomial
systems. If the system doesn't have finite number of solutions we output ``failed`` or fallback
to other methods. We continue this method recursively until we find all solutions for all variables
of the initial system.

To illustrate this process, lets consider a simple bivariate example::

    >>> F = [x*y - 2*y, x**2 - 2*y**2]

We compute a lexicographic |groebner| basis of $F$ assuming that $y \succ x$::

    >>> G = groebner(F, wrt=y)

    >>> G
    ⎡   2                           ⎤
    ⎢  x     2              3      2⎥
    ⎢- ── + y , x⋅y - 2⋅y, x  - 2⋅x ⎥
    ⎣  2                            ⎦

As the last element of the basis we obtained a univariate polynomial in $x$, confirming what
the theory predicted. We can easily solve this polynomial using :func:`roots` function::

    >>> roots(_[-1])
    {0: 2, 2: 1}

We obtained three solutions: $x_1 = 0$, $x_2 = 0$ and $x_3 = 2$. We can substitute them back
into the computed |groebner| basis $G$. We are guaranteed that the resulting polynomials in
each new system will have a nontrivial greatest common divisor. Lets take $x_1$ (the same
will follow for $x_2$)::

    >>> [ g.subs(x, 0) for g in G ]
    ⎡ 2         ⎤
    ⎣y , -2⋅y, 0⎦

    >>> groebner(_, y)
    [y]

So we obtained a solution of $F$, mainly $(x, y) = (0, 0)$ of multiplicity $2$, because
$x_1 = x_2$. The necessity to specify $y$ in the above computation comes from the fact
that currently expression parsing is done independently for each polynomial in the input
system, so without $y$ the function would complain that it doesn't know how to construct
a polynomial from $0$ (see <TODO> section for a detailed discussion). As we know from the
previous section, the |groebner| basis algorithm is equivalent to GCD computation in the
univariate case, so we could have computed GCD of ``[y**2, -2*y, 0]`` as well to obtain
the same result.

Similarly we can can substitute $x_3$ for $x$ in $G$ obtaining::

    >>> [ g.subs(x, 2) for g in G ]
    ⎡ 2          ⎤
    ⎣y  - 2, 0, 0⎦

We got a single univariate polynomial which we can solve by radicals::

    >>> roots(_[0])
    ⎧  ___        ___   ⎫
    ⎨╲╱ 2 : 1, -╲╱ 2 : 1⎬
    ⎩                   ⎭

So the remaining two solutions are $(2, \sqrt{2})$ and $(2, -\sqrt{2})$. This way we found
all solutions of $F$. This was simple example. In more complicated ones we would need to
compute |groebner| bases recursively after each substitution.

An algorithm for solving systems of polynomial equations was implemented in polynomials
manipulation module in SymPy, so we can compute solutions of $F$ issuing a single command::

    >>> solve(F)
    ⎡        ⎛      ___⎞  ⎛     ___⎞⎤
    ⎣(0, 0), ⎝2, -╲╱ 2 ⎠, ⎝2, ╲╱ 2 ⎠⎦

Note that only unique solutions are returned by :func:`solve`. One should also remember that
only systems with finite number of solutions can be handled using |groebner| bases approach.
Suppose we form a new system of polynomial equations $G$ by multiplying $F$ element--wise by
a third variable, say $t$, i.e. ``G = [ t*f for f in F ]``. Then $G$ has infinite number of
solutions, because both polynomials in the system are homogeneous and if $t = 0$ then we can
choose arbitrary values for $x$ and $y$. If $G$ was given as input to :func:`solve`, then it
would result in :exc:`NotImplementedError` exception. Support for solving of systems of
polynomial equations with infinite number of solutions is a subject for implementation
in future versions of SymPy.

Lets back for a moment to the point where we were computing the |groebner| basis of $F$. We
did the computation with respect to $y$, i.e. assuming $y \succ x$. Now we will compute the
|groebner| basis of $F$ the other way::

    >>> groebner(F, wrt=x)
    ⎡ 2      2              3      ⎤
    ⎣x  - 2⋅y , x⋅y - 2⋅y, y  - 2⋅y⎦

As expected, we got a univariate polynomial in $y$, however, a different one::

    >>> roots(_[-1])
    ⎧        ___        ___   ⎫
    ⎨0: 1, ╲╱ 2 : 1, -╲╱ 2 : 1⎬
    ⎩                         ⎭

Previously we got three rational solutions, so after substitution we got polynomials with
rational coefficients and, as a consequence, we could use more efficient algorithms. Now
we run into a little trouble because we will have to carry those square roots all along
our computations. We can't actually complain about this because this is the nature of the
problem we are solving and we were just lucky in the previous case, where algebraic numbers
were introduced at the very end.

There is a method [Strzebonski1997computing]_ to avoid computing with algebraic numbers, which
requires enlarging of the input polynomial system to :func:`groebner`. Instead of substituting
an algebraic number for a variable, we can instead substitute a *dummy* variable for it and add
the minimal polynomial of the algebraic number to the system of equations. This way we have
simpler coefficient domain but a larger system we pass to the |groebner| basis algorithm.
Currently this approach isn't implemented is SymPy.

Algebraic relations in invariant theory
---------------------------------------

Many problems in applied algebra have symmetries or are invariant under certain natural
transformations. In particular, all geometric magnitudes and properties are invariant with
respect to the underlying transformation group, e.g. properties in Euclidean geometry are
invariant under the Euclidean group of rotations (see [Sturmfels2008invariant]_). Analysis
of this structure can give a deep insight into the studied problem.

Following [Buchberger2001introduction]_ and [Sturmfels2008invariant]_ lets consider the
group $\mathbb{Z}_4$ of rotational symmetries in the counter clockwise direction of the
square. The invariant ring of this group is equal to:

.. math::

    \mathcal{I} = \left\{ f \in \mathbb{C}[x_1, x_2] : f(x_1, x_2) = f(-x_2, x_1) \right\}

This ring has three fundamental invariants:

.. math::

    \begin{array}{ccc}
    I_1 = x_1^2 + x_2^2, & I_2 = x_1^2 x_2^2, & I_3 = x_1^3 x_2 - x_1 x_2^3
    \end{array}

Polynomials $I_1$, $I_2$ and $I_3$ form a basis of $I$ and all other polynomials in $I$
can be expressed in terms of them. The first question we may ask in algorithmic invariant
theory is what algebraic dependence relation do $I_1$, $I_2$ and $I_3$ satisfy. In other
words, we would like to find a polynomial $f(i_1, i_2, i_3)$ such that $f(I_1, I_2, I_3)
\equiv 0$. For this purpose we can use |groebner| bases algorithm utilizing, so called,
*slack variable* approach. We introduce three slack variables $i_1$, $i_2$ and $i_3$,
construct a system of polynomial equations $F = \{I_1 - i_1, I_2 - i_2, I_3 - i_3\}$
and compute |groebner| basis of $F$ with respect to lexicographic term order eliminating
$x_1$ and $x_2$. Lets see how this can be accomplished in SymPy using polynomials
manipulation module. First we introduce all the necessary variables and the three
fundamental invariants of $\mathcal{I}$::

    >>> var('x1,x2,i1,i2,i3')
    (x₁, x₂, i₁, i₂, i₃)

    >>> I1 = x1**2 + x2**2
    >>> I2 = x1**2*x2**2
    >>> I3 = x1**3*x2 - x1*x2**3

Next we construct $F$, i.e. define ``F = [I1 - i1, I2 - i2, I3 - i3]``, and finally we
compute lexicographic |groebner| basis of $F$ eliminating $x_1$ and $x_2$::

    >>> G = groebner(F, wrt='x1,x2')

As |groebner| bases computed by :func:`groebner` function are unique and sorted by
decreasing leading monomials, we obtain the desired algebraic dependence relation
between $I_1$, $I_2$ and $I_3$ as the last element of ``G``::

    >>> G[-1]
      2          2     2
    i₁ ⋅i₂ - 4⋅i₂  - i₃

We can verify that this relation is true by substitution, i.e. if we substitute the
fundamental invariants for the slack variables, the above polynomial should vanish::

    >>> _.subs({i1: I1, i2: I2, i3: I3}).expand()
    0

As the result ``G[-1]`` is correct algebraic dependence relation between the fundamental
invariants of $\mathcal{I}$. In this example we learnt another syntax for eliminating
variables using ``wrt`` keyword argument. In previous sections we eliminated just a single
variable with its help, however, in general we can pass arbitrary number of variables via
``wrt``, either by setting it to a string consisting of a sequence of comma separated
variables separated or as on ordered container of variables (e.g. ``list`` or ``tuple``).

When introducing polynomials $I_1$, $I_2$ and $I_3$ it was stated that those polynomials
form a basis for all other polynomials in the ring of rotations of the square. So another
question we may ask is if some polynomial, say $g$ can be expressed in terms of those three
polynomials. Lets consider a polynomial $g = x_1^7 x_2 - x_1 x_2^7$. We want to find a
polynomial $f(i_1, i_2, i_3)$ such that $f(I_1, I_2, I_3) = g$. For this purpose we will
use |groebner| bases approach once again, by reusing previously computed basis $G$. What
remains to do is to reduce the polynomial $g$ with respect to the set $G$ utilizing, as
previously, lexicographic term order eliminating $x_1$ and $x_2$. The reduction of polynomial
by a set of polynomials is accomplished by taking the remainder from the result given by the
generalized multivariate polynomial division algorithm (also known as normal form algorithm)
which is implemented in :func:`reduced` function::

    >>> reduced(x1**7*x2 - x1*x2**7, G, wrt=[x1, x2])[1]
      2
    i₁ ⋅i₃ - i₂⋅i₃

We obtained a polynomial with $x_1$ and $x_2$ eliminated which means that $g$ can be written
in terms of the generators of $\mathcal{I}$ and the above polynomial is the representation of
$g$. As previously, the correctness of this result can be verified by substitution::

    >>> _.subs({i1: f1, i2: f2, i3: f3}).expand()
      7           7
    x₁ ⋅x₂ - x₁⋅x₂

If we take another polynomial, e.g. $g' = x_1^6 x_2 - x_1 x_2^6$, then::

    >>> _, f = reduced(x1**6*x2 - x1*x2**6, G, wrt=[x1, x2])

    >>> f.has(x1, x2)
    True

which means that :func:`reduced` wasn't able to eliminate $x_1$ and/or $x_2$ from $g'$ and
as a consequence $g'$ has no representation in terms of the generators of $\mathcal{I}$,
i.e. $g'$ doesn't belong to $\mathcal{I}$ as $g'(x_1, x_2) \not= g'(-x_2, x_1)$.

Note that in this example we used the list variant of ``wrt`` keyword argument. Likewise in the
case of computing a |groebner| basis, :func:`reduced` assumes by default lexicographic order of
terms, so there was no need to specify this explicitly. In following section we will see that
other orderings, e.g. degree orderings, are also very useful.

.. TODO: symmetric reduction

Integer programming
-------------------



Coloring of graphs
------------------

Graph coloring, which is one of the oldest and best--known subfields of graph theory, is an
assigning values from a finite set, traditionally called colors, to elements (e.g. vertices,
edges) of a graph. The assignment is a subject to various constraints. Coloring of graphs is
a powerful technique for solving many practical discrete optimization problems, e.g. in
operational research, like scheduling, resource allocation and many other. Graph colorings
are also very interesting on their own due to their intrinsic complexity, as in the general
case (without any assumptions on the structure of the input graph) they are NP--hard problems,
i.e. there are no polynomial time algorithms for finding graph colorings (for a detailed
discussion see [Kubale2004color]_).

In the rest of this section we will show how to use SymPy for solving graph coloring problems
using |groebner| bases. Following the discussion [Adams1994intro]_, the first subject we will
focus on is the classical problem of vertex--coloring. Given a graph $\mathcal{G}(V, E)$, where
$V$ is the set of vertices of $\mathcal{G}$ and $E$ is the set of edges of $\mathcal{G}$, and a
positive integer $k$ we ask if is possible to assign a color to every vertex from $V$, such that
adjacent vertices have different colors assigned. Moreover, we can extend our question and ask
for all possible $k$--colorings of $\mathcal{G}$ or just for the number of $k$--colorings.

It shouldn't be that strange to use |groebner| bases for a graph theoretical problem. After
all, |groebner| bases have intrinsic complexity at least equal to the complexity of graph
coloring problems and allow for analysis of the structure of the studied problem.

But how do we transform a graph and coloring constraints into an algebraic problem? First we
need to assign a variable to each vertex. Given that $\mathcal{G}$ has $n$ vertices, i.e.
$|V| = n$, then we will have variables $x_1, x_2, \ldots, x_n$. Next we will write a set of
equations describing the fact that we allow an assignment of one of $k$ possible colors to every
vertex.  The currently best known approach to this problem is to map colors to primitive $k$--th
roots of unity. Let $\zeta = \exp(\frac{2\pi}{k})$ be a root of unity so that $\zeta^k = 1$. We
map colors $1, 2, \ldots, k$ to $k$ distinct roots of unity $1, \zeta, \ldots, \zeta^{k-1}$. As
$k$--th roots of unity are solutions to equation of the form $x_i^k - 1$ then the statement
that every vertex has to be assigned a color is equivalent to writing a set of polynomial
equations:

.. math::

    F_k = \{ x_i^k - 1 : i = 1, 2, \ldots, n \}

We also require that two adjacent vertices $x_i$ and $x_j$ are assigned different colors.
From the previous discussion we know that $x_i^k = 1$ and $x_j^k = 1$, so $x_i^k = x_j^k$
or, equivalently, $x_i^k - x_j^k = 0$. By factorization we can obtain that $x_i^k - x_j^k
= (x_i - x_j) \cdot f(x_i, x_j) = 0$. Since we require that $x_i \not= x_j$ then $x_i^k -
x_j^k$ can vanish only when $f(x_i, x_j) = 0$. This allows us to write another set of
polynomial equations:

.. math::

    F_{\mathcal{G}} = \{ f(x_i, x_j) : (i, j) \in E \}

We combine $F_k$ and $F_{\mathcal{G}}$ into one system of equations $F$. Let $\mathcal{I}$ be
the ideal of $\mathbb{C}[x_1,\ldots,x_n]$ generated by $F$ and let $\mathcal{V}(\mathcal{I})$
be an algebraic variety in $\mathbb{C}^n$. Then a graph $\mathcal{G}$ is $k$--colorable if
$\mathcal{V}(\mathcal{I}) \not= \emptyset$. To verify this statement it is sufficient to compute
a |groebner| basis $G$ of $F$ and check if $G \not= \{1\}$. If this is the case, then the graph
isn't $k$--colorable. Otherwise the |groebner| basis gives us explicit information about all
possible $k$--colorings of $\mathcal{G}$. Speaking in less formal language, given a set of
polynomial equations $F$ which describe geometry of a graph and coloring constraints we look
for solutions of this system of equations in $\mathbb{C}^n$. If we can find solutions of any
kind then the graph is colorable with $k$ colors.

Lets now focus on a particular and well known instance of $k$--coloring where $k = 3$. In this
case $F_3 = \{ x_i^3 - 1 : i = 1, \ldots, n \}$. Using SymPy's built--in multivariate polynomial
factorization routine::

    >>> var('x_i, x_j')
    (x_i, x_j)

    >>> factor(x_i**3 - x_j**3)
                ⎛   2                2⎞
    (x_i - x_j)⋅⎝x_i  + x_i⋅x_j + x_j ⎠

we derive the set of equations $F_{\mathcal{G}}$ describing an admissible $3$--coloring of a graph:

.. math::

    F_{\mathcal{G}} = \{ x_i^2 + x y + x_j^2 : (i, j) \in E \}

At this point it is sufficient to compute the |groebner| basis $G$ of $F = F_3 \cup F_{\mathcal{G}}$
to find out if a graph $\mathcal{G}$ is $3$--colorable, or not. After this theoretical introduction
lets consider a graph $\mathcal{G}(V, E)$ of figure :ref:`fig-graph-nocolor` with 12 vertices and
23 edges, to see that the described scheme works in practice. We ask if the graph is $3$--colorable.
In this example we will first show how to answer this question SymPy and then we will compare this
with three other symbolic manipulation systems on the market: Maxima, Axiom and Mathematica.

.. tikz:: img/tikz/graph-nocolor.tex

.. _fig-graph-nocolor:
.. figure:: ../img/tikz/graph-nocolor.*
    :align: center

    The graph $\mathcal{G}(V, E)$.

The question, if $\mathcal{G}$ is $3$--colorable or not, is easy to answer by trial and error. We
are, however, an interested in algorithmic solution to the problem, so lets first encode $V$ and
$E$ of the graph $\mathcal{G}$ using Python's built--in data structures::

    >>> V = range(1, 12+1)
    >>> E = [(1,2),(2,3),(1,4),(1,6),(1,12),(2,5),(2,7),(3,8),
    ... (3,10),(4,11),(4,9),(5,6),(6,7),(7,8),(8,9),(9,10),
    ... (10,11),(11,12),(5,12),(5,9),(6,10),(7,11),(8,12)]

We encoded the set of vertices as a list of consecutive integers and the set of edges as a list
of tuples of adjacent vertex indices. Next we will transform the graph into an algebraic form by
mapping vertices to variables and tuples of indices into tuples of variables::

    >>> Vx = [ Symbol('x' + str(i)) for i in V ]
    >>> Ex = [ (Vx[i-1], Vx[j-1]) for i, j in E ]

As the last step of this construction we write equations for $F_3$ and $F_{\mathcal{G}}$::

    >>> F3 = [ x**3 - 1 for x in Vx ]
    >>> Fg = [ x**2 + x*y + y**2 for x, y in Ex ]

Everything is set following the theoretical introduction, so now we can compute the |groebner|
basis of $F_3 \cup F_{\mathcal{G}}$ with respect to *lexicographic* ordering of terms::

    >>> G = groebner(F3 + Fg, Vx)

We know that if the constructed system of polynomial equations has a solution then $G$ should be
non--trivial, i.e. $G \not= \emptyset$, which can be easily verified in SymPy::

    >>> G != [1]
    True

The answer is that the graph $\mathcal{G}$ is colorable with $3$ colors. A sample coloring is shown
in figure :ref:`fig-graph-color`. Suppose we add an edge between vertices $i = 3$ and $j = 4$. Is
the new graph $3$--colorable? To check this it is sufficient to construct $F_{\mathcal{G'}}$ by
extending $F_{\mathcal{G}}$ with $x_3^2 + x_3 x_4 + x_4^2$ equation and recompute the |groebner|
basis::

    >>> x3, x4 = Vx[2], Vx[3]

    >>> G = groebner(F3 + Fg + [x3**2 + x3*x4 + x4**2], Vx)

    >>> G != [1]
    False

We got a trivial |groebner| basis as the result, so the graph $\mathcal{G'}$ isn't $3$--colorable. We
could continue this discussion asking if $\mathcal{G'}$ is $4$--colorable or if the number of colors
required to color the original graph could be lowered to $2$ colors.

.. tikz:: img/tikz/graph-color.tex

.. _fig-graph-color:
.. figure:: ../img/tikz/graph-color.*
    :align: center

    A sample $3$--coloring of the graph $\mathcal{G}(V, E)$.

Before we compare SymPy's syntax for computing |groebner| bases with other systems, let us clarify an
issue arousing around list indexing (e.g. why we write ``x3 = Vx[2]``). SymPy is a library built on top
of Python, so it utilizes Python's built--in data structures and their indexing schemes. Python, as a
general purpose programming language, uses well established zero--based indexing scheme, contrary to the
natural way of *indexing* things, i.e. saying 1st, 2nd, 3rd etc. (to which we are accustomed in real life
and mathematics). The zero--based indexing scheme dates back to the time of first programming languages,
which were hardware oriented (e.g. assemblers) and an index was understood as an offset from a particular
location in memory (the start of a container) to the requested item (for a more detailed discussion about
this issue see [Dijkstra1982zero]_). General purpose programming languages, even those interpreted like
Python, coherently follow this scheme. For SymPy, this is a cost of building the system on top of a general
purpose language. As we will see in the following examples, other symbolic manipulation systems, i.e. those
which invent their own programming language, use *natural indexing* scheme. Currently a workaround to have
one--based indexing in SymPy, is to append a dummy element in front of a list, e.g. to index ``Vx`` this
way we could issue ``Vx = [None] + Vx`` and then ``x3 = Vx[3]``.



