.. include:: ../globals.def

.. _thesis-groebner:

=======================================================
Introduction to |groebner| bases and their applications
=======================================================



Specialization of |groebner| bases
==================================

The |groebner| bases algorithm specializes to:

1. *Gauss's algorithm* for linear polynomials
2. *Euclid's algorithm* for univariate polynomials

In the first case lets consider the following equation system:

.. math::

    \left\{
    \begin{array}{rcl}
       x + 5 y &=& 2    \\
    -3 x + 6 y &=& 15
    \end{array}
    \right.

which can be written in Python as::

    >>> F = [x + 5*y - 2, -3*x + 6*y - 15]

It's a simple system, so it can be solved by hand. We can, however, uses |groebner| bases
algorithm to solve this system algorithmically::

    >>> groebner(F, x, y)
    [x + 3, y - 1]

As the result we got a list of two polynomials. From te list we can obtain the solution
of the system, which is $x = -3$ and $y = 1$ in this case. The same can be computed using
a much more traditional tool in the field of linear algebra, mainly using Gauss--Jordan
algorithm::

    >>> solve(F, x, y)
    {x: -3, y: 1}

We obtained the same solution but in the dictionary form this time. It's interesting to
notice that currently, at least for small inputs, the |groebner| bases approach is much
faster than using a specialized solver. Lets compare efficiency of those two methods::

    >>> %timeit groebner(F, x, y)
    100 loops, best of 3: 5.15 ms per loop

    >>> %timeit solve(F, x, y)
    10 loops, best of 3: 22.7 ms per loop

An explanation of this result is as follows: |groebner| bases utilize very efficient core
of polynomials manipulation module, whereas :func:`solve` uses inefficient implementation
of linear algebra in SymPy. This situation will change and the observed phenomenon will
disappear in future, when linear algebra module is refactored (using similar approach
to what was done to polynomials module).

Lets now focus on the other case, i.e. on computation of the greatest common divisors. For
this, consider two univariate polynomials ``f`` and ``g``, both in the indeterminate ``x``
with coefficients in the ring of integers::

    >>> f = expand((x - 2)**3 * (x + 3)**4 * (x + 7))
    >>> g = expand((x + 2)**3 * (x + 3)**3 * (x + 7))

We can easily see that those polynomials have to factors in common (of multiplicity three
and one respectively). Lets verify this observation using |groebner| bases algorithm once
again::

    >>> groebner([f, g])
    ⎡ 4       3       2              ⎤
    ⎣x  + 16⋅x  + 90⋅x  + 216⋅x + 189⎦

We obtained a polynomial of degree four which clearly verifies observation concerning
multiplicities of the commons factors of ``f`` and ``g``. Lets add more structure to
the computed polynomial GCD using factorization::

    >>> factor(_[0])
           3
    (x + 3) ⋅(x + 7)

Now we can clearly see the common factors of the input polynomials. Although utilization
of |groebner| bases algorithm for computing GCDs of univariate polynomials is very fancy,
there are much more efficient algorithm for this purpose. In SymPy we use heuristic GCD
algorithm (over integers and rationals) and subresultants (over other domains).

Moreover, |groebner| bases can be used to compute greatest common divisors of multivariate
polynomials (see [Cox1997ideals]_). The algorithm reduces the problem of finding the GCD of
two multivariate polynomials, say ``f`` and ``g``, into the problem of finding their least
common multiple. The final result is obtained using the well known formula that relates
GCD with LCM:

.. math::
    :label: gcdlcm

    \gcd(f, g) = \frac{f \cdot g}{\operatorname{lcm}(f, g)}

The multivariate polynomial LCM is computed as the unique generator of the intersection of
the two ideals generated by ``f`` and ``g``. The approach is to compute a |groebner| basis
of $t \cdot f$ and $(1 - t) \cdot g$, where $t$ is an unrelated variable, with respect to
lexicographic order of terms which eliminates $t$. The polynomial LCM of ``f`` and ``g``
is the last element of the computed |groebner| basis.

As an example consider the following two bivariate polynomials over integers::

    >>> f = expand((x - 1)**3 * (x + y)**4 * (x - y))
    >>> g = expand((x + 1)**3 * (x + y)**3 * (x - y))

To compute the GCD of ``f`` and ``g`` we will introduce new variable $t$ and then we will
find a |groebner| basis of $t \cdot f$ and $(1 - t) \cdot g$ which eliminates $t$::

    >>> basis = groebner([t*f, (1 - t)*g], t, x, y)

Note that the order of variables is significant. We chose $t$ to be of higher rank than
$x$ or $y$ to allow |groebner| basis algorithm to eliminate it from the last element of
the basis. As the relative rank of $x$ and $y$ is not important in this case, we can
rewrite the above expression in a slightly different form::

    >>> basis = groebner([t*f, (1 - t)*g], wrt=t)

This syntax signifies that the only important knowledge here is that $t$ comes before
any other variable. This approach is also far more general because we could use input
polynomials with more variables without changing the algorithm, as long as there is no
clash of variables with $t$. We can guarantee that this won't happen by declaring $t$
as a *dummy* variable, i.e. ``t = Symbol('t', dummy=True)``.

Also one should note that we didn't specify the order of terms in |groebner| basis
computation. As we use *lexicographic* order for computing the LCM of ``f`` and ``g``
we need to provide no further information, because all algorithms in polynomials
manipulation module use *lexicographic* order of terms by default.

Given a |groebner| basis of the ideal generated by ``f`` and ``g``, the last element
of this basis is the desired LCM. By using formula :eq:`gcdlcm` we can compute the
greatest common divisor of the input polynomials::

    >>> quo(f*g, basis[-1])
     4        3        3    4
    x  + 2⋅y⋅x  - 2⋅x⋅y  - y

    >>> factor(_)
           3
    (x + y) ⋅(x - y)

We obtained the correct GCD of ``f`` and ``g``. As in the univariate case, the same
result can computed, thought much more efficiently, using :func:`gcd` function, which
utilizes specialized algorithms for computing greatest common divisors.

Historically this was the first algorithm for computing GCDs of multivariate polynomials
in SymPy. Although it's not a very efficient approach to the problem, it can serve as a
good explanation of |groebner| bases machinery. Currently we use heuristic GCD algorithm
for the task and there are plans to implement EEZ algorithm for this task (see section
:ref:`thesis-gcd` for more details).

Reduced |groebner| bases
========================

Complexity of computing |groebner| bases
========================================

::
    GroebnerBasis[{x y^3 - 2 y z - z^2 + 13, y^2 - x^2 z + x z^2 + 3, z^2 x - y^2 x^2 + x y + y^3 + 12}]

::
    groebner([x*y**3 - 2*y*z - z**2 + 13, y**2 - x**2*z + x*z**2 + 3, z**2*x - y**2*x**2 + x*y + y**3 + 12], x, y, z)

A few applications of |groebner| bases
======================================

Solving systems of equations
----------------------------

Vertex-coloring of graphs
-------------------------

.. math::

    V(I)


.. [math-impl] http://reference.wolfram.com/mathematica/note/SomeNotesOnInternalImplementation.html

